/*
 * generated by Xtext 2.20.0
 */
package org.palladiosimulator.commons.stoex.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class StoexGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.expression");
		private final RuleCall cIfelseExprParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		////#############################
		//// start-rule:
		//// expression -> ifelseExpr
		//expression Expression:
		//	ifelseExpr;
		@Override public ParserRule getRule() { return rule; }
		
		//ifelseExpr
		public RuleCall getIfelseExprParserRuleCall() { return cIfelseExprParserRuleCall; }
	}
	public class IfelseExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ifelseExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBoolAndExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cIfElseExpressionConditionExpressionAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cQuestionMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cIfExpressionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIfExpressionBoolAndExprParserRuleCall_1_2_0 = (RuleCall)cIfExpressionAssignment_1_2.eContents().get(0);
		private final Keyword cColonKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cElseExpressionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cElseExpressionBoolAndExprParserRuleCall_1_4_0 = (RuleCall)cElseExpressionAssignment_1_4.eContents().get(0);
		
		////#############################
		//// Stochastic Expressions:
		//// ifelseExpr -> boolAndExpr ('?' boolAndExpr ':' boolAndExpr)?
		//ifelseExpr IfElse:
		//	boolAndExpr ({IfElseExpression.conditionExpression=current} '?' ifExpression=boolAndExpr ':'
		//	elseExpression=boolAndExpr)?;
		@Override public ParserRule getRule() { return rule; }
		
		//boolAndExpr ({IfElseExpression.conditionExpression=current} '?' ifExpression=boolAndExpr ':'
		//elseExpression=boolAndExpr)?
		public Group getGroup() { return cGroup; }
		
		//boolAndExpr
		public RuleCall getBoolAndExprParserRuleCall_0() { return cBoolAndExprParserRuleCall_0; }
		
		//({IfElseExpression.conditionExpression=current} '?' ifExpression=boolAndExpr ':' elseExpression=boolAndExpr)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{IfElseExpression.conditionExpression=current}
		public Action getIfElseExpressionConditionExpressionAction_1_0() { return cIfElseExpressionConditionExpressionAction_1_0; }
		
		//'?'
		public Keyword getQuestionMarkKeyword_1_1() { return cQuestionMarkKeyword_1_1; }
		
		//ifExpression=boolAndExpr
		public Assignment getIfExpressionAssignment_1_2() { return cIfExpressionAssignment_1_2; }
		
		//boolAndExpr
		public RuleCall getIfExpressionBoolAndExprParserRuleCall_1_2_0() { return cIfExpressionBoolAndExprParserRuleCall_1_2_0; }
		
		//':'
		public Keyword getColonKeyword_1_3() { return cColonKeyword_1_3; }
		
		//elseExpression=boolAndExpr
		public Assignment getElseExpressionAssignment_1_4() { return cElseExpressionAssignment_1_4; }
		
		//boolAndExpr
		public RuleCall getElseExpressionBoolAndExprParserRuleCall_1_4_0() { return cElseExpressionBoolAndExprParserRuleCall_1_4_0; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BooleanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBoolOrExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperatorExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationBooleanOperationsEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBoolOrExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		////BooleanExpression -> boolOrExpr (BooleanOperations boolOrExpr)*
		//// Note: This is a workaround for the serializer to work with AND-Operations!
		//BooleanExpression:
		//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=BooleanOperations right=boolOrExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//boolOrExpr ({BooleanOperatorExpression.left=current} operation=BooleanOperations right=boolOrExpr)*
		public Group getGroup() { return cGroup; }
		
		//boolOrExpr
		public RuleCall getBoolOrExprParserRuleCall_0() { return cBoolOrExprParserRuleCall_0; }
		
		//({BooleanOperatorExpression.left=current} operation=BooleanOperations right=boolOrExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BooleanOperatorExpression.left=current}
		public Action getBooleanOperatorExpressionLeftAction_1_0() { return cBooleanOperatorExpressionLeftAction_1_0; }
		
		//operation=BooleanOperations
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//BooleanOperations
		public RuleCall getOperationBooleanOperationsEnumRuleCall_1_1_0() { return cOperationBooleanOperationsEnumRuleCall_1_1_0; }
		
		//right=boolOrExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//boolOrExpr
		public RuleCall getRightBoolOrExprParserRuleCall_1_2_0() { return cRightBoolOrExprParserRuleCall_1_2_0; }
	}
	public class BoolAndExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.boolAndExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cBoolOrExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperatorExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationAndoperationEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightBoolOrExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// boolAndExpr -> boolOrExpr (andoperation boolOrExpr)*
		//boolAndExpr BooleanExpression:
		//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//boolOrExpr ({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*
		public Group getGroup() { return cGroup; }
		
		//boolOrExpr
		public RuleCall getBoolOrExprParserRuleCall_0() { return cBoolOrExprParserRuleCall_0; }
		
		//({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BooleanOperatorExpression.left=current}
		public Action getBooleanOperatorExpressionLeftAction_1_0() { return cBooleanOperatorExpressionLeftAction_1_0; }
		
		//operation=andoperation
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//andoperation
		public RuleCall getOperationAndoperationEnumRuleCall_1_1_0() { return cOperationAndoperationEnumRuleCall_1_1_0; }
		
		//right=boolOrExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//boolOrExpr
		public RuleCall getRightBoolOrExprParserRuleCall_1_2_0() { return cRightBoolOrExprParserRuleCall_1_2_0; }
	}
	public class BoolOrExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.boolOrExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cCompareExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cBooleanOperatorExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationOroperationsEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightCompareExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// boolOrExpr -> compareExpr (oroperations compareExpr)*
		//boolOrExpr BooleanExpression:
		//	compareExpr ({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//compareExpr ({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*
		public Group getGroup() { return cGroup; }
		
		//compareExpr
		public RuleCall getCompareExprParserRuleCall_0() { return cCompareExprParserRuleCall_0; }
		
		//({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{BooleanOperatorExpression.left=current}
		public Action getBooleanOperatorExpressionLeftAction_1_0() { return cBooleanOperatorExpressionLeftAction_1_0; }
		
		//operation=oroperations
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//oroperations
		public RuleCall getOperationOroperationsEnumRuleCall_1_1_0() { return cOperationOroperationsEnumRuleCall_1_1_0; }
		
		//right=compareExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//compareExpr
		public RuleCall getRightCompareExprParserRuleCall_1_2_0() { return cRightCompareExprParserRuleCall_1_2_0; }
	}
	public class CompareExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.compareExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cSumExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cCompareExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationCompareOperationsEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightSumExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// compareExpr -> sumExpr (CompareOperations sumExpr)?
		//compareExpr Comparison:
		//	sumExpr ({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?;
		@Override public ParserRule getRule() { return rule; }
		
		//sumExpr ({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?
		public Group getGroup() { return cGroup; }
		
		//sumExpr
		public RuleCall getSumExprParserRuleCall_0() { return cSumExprParserRuleCall_0; }
		
		//({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{CompareExpression.left=current}
		public Action getCompareExpressionLeftAction_1_0() { return cCompareExpressionLeftAction_1_0; }
		
		//operation=CompareOperations
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//CompareOperations
		public RuleCall getOperationCompareOperationsEnumRuleCall_1_1_0() { return cOperationCompareOperationsEnumRuleCall_1_1_0; }
		
		//right=sumExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//sumExpr
		public RuleCall getRightSumExprParserRuleCall_1_2_0() { return cRightSumExprParserRuleCall_1_2_0; }
	}
	public class SumExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.sumExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cProdExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cTermExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationTermOperationsEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightProdExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// sumExpr -> prodExpr (TermOperations prodExpr)*
		//sumExpr Term:
		//	prodExpr ({TermExpression.left=current} operation=TermOperations right=prodExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//prodExpr ({TermExpression.left=current} operation=TermOperations right=prodExpr)*
		public Group getGroup() { return cGroup; }
		
		//prodExpr
		public RuleCall getProdExprParserRuleCall_0() { return cProdExprParserRuleCall_0; }
		
		//({TermExpression.left=current} operation=TermOperations right=prodExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{TermExpression.left=current}
		public Action getTermExpressionLeftAction_1_0() { return cTermExpressionLeftAction_1_0; }
		
		//operation=TermOperations
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//TermOperations
		public RuleCall getOperationTermOperationsEnumRuleCall_1_1_0() { return cOperationTermOperationsEnumRuleCall_1_1_0; }
		
		//right=prodExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//prodExpr
		public RuleCall getRightProdExprParserRuleCall_1_2_0() { return cRightProdExprParserRuleCall_1_2_0; }
	}
	public class ProdExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.prodExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cPowExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cProductExpressionLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cOperationAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperationProductOperationsEnumRuleCall_1_1_0 = (RuleCall)cOperationAssignment_1_1.eContents().get(0);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightPowExprParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//// prodExpr -> powExpr (ProductOperations powExpr)*
		//prodExpr Product:
		//	powExpr ({ProductExpression.left=current} operation=ProductOperations right=powExpr)*;
		@Override public ParserRule getRule() { return rule; }
		
		//powExpr ({ProductExpression.left=current} operation=ProductOperations right=powExpr)*
		public Group getGroup() { return cGroup; }
		
		//powExpr
		public RuleCall getPowExprParserRuleCall_0() { return cPowExprParserRuleCall_0; }
		
		//({ProductExpression.left=current} operation=ProductOperations right=powExpr)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{ProductExpression.left=current}
		public Action getProductExpressionLeftAction_1_0() { return cProductExpressionLeftAction_1_0; }
		
		//operation=ProductOperations
		public Assignment getOperationAssignment_1_1() { return cOperationAssignment_1_1; }
		
		//ProductOperations
		public RuleCall getOperationProductOperationsEnumRuleCall_1_1_0() { return cOperationProductOperationsEnumRuleCall_1_1_0; }
		
		//right=powExpr
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }
		
		//powExpr
		public RuleCall getRightPowExprParserRuleCall_1_2_0() { return cRightPowExprParserRuleCall_1_2_0; }
	}
	public class PowExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.powExpr");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExprParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPowerExpressionBaseAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExponentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExponentUnaryExprParserRuleCall_1_2_0 = (RuleCall)cExponentAssignment_1_2.eContents().get(0);
		
		//// powExpr -> unaryExpr (POW unaryExpr)?
		//powExpr Power:
		//	unaryExpr ({PowerExpression.base=current} '^' exponent=unaryExpr)?;
		@Override public ParserRule getRule() { return rule; }
		
		//unaryExpr ({PowerExpression.base=current} '^' exponent=unaryExpr)?
		public Group getGroup() { return cGroup; }
		
		//unaryExpr
		public RuleCall getUnaryExprParserRuleCall_0() { return cUnaryExprParserRuleCall_0; }
		
		//({PowerExpression.base=current} '^' exponent=unaryExpr)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{PowerExpression.base=current}
		public Action getPowerExpressionBaseAction_1_0() { return cPowerExpressionBaseAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//exponent=unaryExpr
		public Assignment getExponentAssignment_1_2() { return cExponentAssignment_1_2; }
		
		//unaryExpr
		public RuleCall getExponentUnaryExprParserRuleCall_1_2_0() { return cExponentUnaryExprParserRuleCall_1_2_0; }
	}
	public class UnaryExprElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.unaryExpr");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cNegativeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNotExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cAtomParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//// unaryExpr -> NegativeExpression | NotExpression | atom
		//unaryExpr Unary:
		//	NegativeExpression | NotExpression | atom;
		@Override public ParserRule getRule() { return rule; }
		
		//NegativeExpression | NotExpression | atom
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//NegativeExpression
		public RuleCall getNegativeExpressionParserRuleCall_0() { return cNegativeExpressionParserRuleCall_0; }
		
		//NotExpression
		public RuleCall getNotExpressionParserRuleCall_1() { return cNotExpressionParserRuleCall_1; }
		
		//atom
		public RuleCall getAtomParserRuleCall_2() { return cAtomParserRuleCall_2; }
	}
	public class NotExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.NotExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cNOTKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInnerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInnerUnaryExprParserRuleCall_1_0 = (RuleCall)cInnerAssignment_1.eContents().get(0);
		
		//// NotExpression -> NOT unaryExpr
		//NotExpression:
		//	'NOT' inner=unaryExpr;
		@Override public ParserRule getRule() { return rule; }
		
		//'NOT' inner=unaryExpr
		public Group getGroup() { return cGroup; }
		
		//'NOT'
		public Keyword getNOTKeyword_0() { return cNOTKeyword_0; }
		
		//inner=unaryExpr
		public Assignment getInnerAssignment_1() { return cInnerAssignment_1; }
		
		//unaryExpr
		public RuleCall getInnerUnaryExprParserRuleCall_1_0() { return cInnerUnaryExprParserRuleCall_1_0; }
	}
	public class NegativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.NegativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInnerAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInnerUnaryExprParserRuleCall_1_0 = (RuleCall)cInnerAssignment_1.eContents().get(0);
		
		//// NegativeExpression -> '-' unaryExpr
		//NegativeExpression:
		//	'-' inner=unaryExpr;
		@Override public ParserRule getRule() { return rule; }
		
		//'-' inner=unaryExpr
		public Group getGroup() { return cGroup; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//inner=unaryExpr
		public Assignment getInnerAssignment_1() { return cInnerAssignment_1; }
		
		//unaryExpr
		public RuleCall getInnerUnaryExprParserRuleCall_1_0() { return cInnerUnaryExprParserRuleCall_1_0; }
	}
	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIntLiteralParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDoubleLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cStringLiteralParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBoolLiteralParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cFunctionLiteralParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cVariableParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cParenthesisParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cProbabilityFunctionLiteralParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		
		//// atom -> 	IntLiteral | DoubleLiteral |StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis | ProbabilityFunctionLiteral
		//atom Atom:
		//	IntLiteral | DoubleLiteral | StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis |
		//	ProbabilityFunctionLiteral;
		@Override public ParserRule getRule() { return rule; }
		
		//IntLiteral | DoubleLiteral | StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis |
		//ProbabilityFunctionLiteral
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IntLiteral
		public RuleCall getIntLiteralParserRuleCall_0() { return cIntLiteralParserRuleCall_0; }
		
		//DoubleLiteral
		public RuleCall getDoubleLiteralParserRuleCall_1() { return cDoubleLiteralParserRuleCall_1; }
		
		//StringLiteral
		public RuleCall getStringLiteralParserRuleCall_2() { return cStringLiteralParserRuleCall_2; }
		
		//BoolLiteral
		public RuleCall getBoolLiteralParserRuleCall_3() { return cBoolLiteralParserRuleCall_3; }
		
		//FunctionLiteral
		public RuleCall getFunctionLiteralParserRuleCall_4() { return cFunctionLiteralParserRuleCall_4; }
		
		//Variable
		public RuleCall getVariableParserRuleCall_5() { return cVariableParserRuleCall_5; }
		
		//Parenthesis
		public RuleCall getParenthesisParserRuleCall_6() { return cParenthesisParserRuleCall_6; }
		
		//ProbabilityFunctionLiteral
		public RuleCall getProbabilityFunctionLiteralParserRuleCall_7() { return cProbabilityFunctionLiteralParserRuleCall_7; }
	}
	public class DoubleLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.DoubleLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValueDOUBLETerminalRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUnitAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUnitUnitParserRuleCall_1_1_0 = (RuleCall)cUnitAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//// DoubleLiteral -> DOUBLE ('[' Unit ']')?
		//DoubleLiteral:
		//	value=DOUBLE ('[' unit=Unit ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DOUBLE ('[' unit=Unit ']')?
		public Group getGroup() { return cGroup; }
		
		//value=DOUBLE
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DOUBLE
		public RuleCall getValueDOUBLETerminalRuleCall_0_0() { return cValueDOUBLETerminalRuleCall_0_0; }
		
		//('[' unit=Unit ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//unit=Unit
		public Assignment getUnitAssignment_1_1() { return cUnitAssignment_1_1; }
		
		//Unit
		public RuleCall getUnitUnitParserRuleCall_1_1_0() { return cUnitUnitParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class ProbabilityFunctionLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ProbabilityFunctionLiteral");
		private final Assignment cFunction_ProbabilityFunctionLiteralAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cFunction_ProbabilityFunctionLiteralDefinitionParserRuleCall_0 = (RuleCall)cFunction_ProbabilityFunctionLiteralAssignment.eContents().get(0);
		
		//// ProbabilityFunctionLiteral -> definition
		//ProbabilityFunctionLiteral:
		//	function_ProbabilityFunctionLiteral=definition;
		@Override public ParserRule getRule() { return rule; }
		
		//function_ProbabilityFunctionLiteral=definition
		public Assignment getFunction_ProbabilityFunctionLiteralAssignment() { return cFunction_ProbabilityFunctionLiteralAssignment; }
		
		//definition
		public RuleCall getFunction_ProbabilityFunctionLiteralDefinitionParserRuleCall_0() { return cFunction_ProbabilityFunctionLiteralDefinitionParserRuleCall_0; }
	}
	public class ParenthesisElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.Parenthesis");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cInnerExpressionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cInnerExpressionIfelseExprParserRuleCall_1_0 = (RuleCall)cInnerExpressionAssignment_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//// Parenthesis -> '(' ifelseExpr ')'
		//Parenthesis:
		//	'(' innerExpression=ifelseExpr ')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' innerExpression=ifelseExpr ')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//innerExpression=ifelseExpr
		public Assignment getInnerExpressionAssignment_1() { return cInnerExpressionAssignment_1; }
		
		//ifelseExpr
		public RuleCall getInnerExpressionIfelseExprParserRuleCall_1_0() { return cInnerExpressionIfelseExprParserRuleCall_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class FunctionLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.FunctionLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cIdAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cIdIDTerminalRuleCall_0_0 = (RuleCall)cIdAssignment_0.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParameters_FunctionLiteralAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParameters_FunctionLiteralBoolAndExprParserRuleCall_2_0_0 = (RuleCall)cParameters_FunctionLiteralAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParameters_FunctionLiteralAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParameters_FunctionLiteralBoolAndExprParserRuleCall_2_1_1_0 = (RuleCall)cParameters_FunctionLiteralAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// FunctionLiteral -> ID '(' (boolAndExpr (',' boolAndExpr)* )? ')'
		//FunctionLiteral:
		//	id=ID '(' (parameters_FunctionLiteral+=boolAndExpr (',' parameters_FunctionLiteral+=boolAndExpr)*)? ')';
		@Override public ParserRule getRule() { return rule; }
		
		//id=ID '(' (parameters_FunctionLiteral+=boolAndExpr (',' parameters_FunctionLiteral+=boolAndExpr)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//id=ID
		public Assignment getIdAssignment_0() { return cIdAssignment_0; }
		
		//ID
		public RuleCall getIdIDTerminalRuleCall_0_0() { return cIdIDTerminalRuleCall_0_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameters_FunctionLiteral+=boolAndExpr (',' parameters_FunctionLiteral+=boolAndExpr)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//parameters_FunctionLiteral+=boolAndExpr
		public Assignment getParameters_FunctionLiteralAssignment_2_0() { return cParameters_FunctionLiteralAssignment_2_0; }
		
		//boolAndExpr
		public RuleCall getParameters_FunctionLiteralBoolAndExprParserRuleCall_2_0_0() { return cParameters_FunctionLiteralBoolAndExprParserRuleCall_2_0_0; }
		
		//(',' parameters_FunctionLiteral+=boolAndExpr)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//parameters_FunctionLiteral+=boolAndExpr
		public Assignment getParameters_FunctionLiteralAssignment_2_1_1() { return cParameters_FunctionLiteralAssignment_2_1_1; }
		
		//boolAndExpr
		public RuleCall getParameters_FunctionLiteralBoolAndExprParserRuleCall_2_1_1_0() { return cParameters_FunctionLiteralBoolAndExprParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class VariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.Variable");
		private final Assignment cId_VariableAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cId_VariableAbstractNamedReferenceParserRuleCall_0 = (RuleCall)cId_VariableAssignment.eContents().get(0);
		
		//// Variable -> AbstractNamedReference
		//Variable:
		//	id_Variable=AbstractNamedReference;
		@Override public ParserRule getRule() { return rule; }
		
		//id_Variable=AbstractNamedReference
		public Assignment getId_VariableAssignment() { return cId_VariableAssignment; }
		
		//AbstractNamedReference
		public RuleCall getId_VariableAbstractNamedReferenceParserRuleCall_0() { return cId_VariableAbstractNamedReferenceParserRuleCall_0; }
	}
	public class AbstractNamedReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.AbstractNamedReference");
		private final RuleCall cNamespaceReferenceParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// AbstractNamedReference -> VariableReference|NamespaceReference
		//AbstractNamedReference:
		//	NamespaceReference;
		@Override public ParserRule getRule() { return rule; }
		
		//NamespaceReference
		public RuleCall getNamespaceReferenceParserRuleCall() { return cNamespaceReferenceParserRuleCall; }
	}
	public class VariableReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.VariableReference");
		private final Assignment cReferenceNameAssignment = (Assignment)rule.eContents().get(1);
		private final Alternatives cReferenceNameAlternatives_0 = (Alternatives)cReferenceNameAssignment.eContents().get(0);
		private final Keyword cReferenceNameBYTESIZEKeyword_0_0 = (Keyword)cReferenceNameAlternatives_0.eContents().get(0);
		private final Keyword cReferenceNameVALUEKeyword_0_1 = (Keyword)cReferenceNameAlternatives_0.eContents().get(1);
		private final Keyword cReferenceNameSTRUCTUREKeyword_0_2 = (Keyword)cReferenceNameAlternatives_0.eContents().get(2);
		private final Keyword cReferenceNameTYPEKeyword_0_3 = (Keyword)cReferenceNameAlternatives_0.eContents().get(3);
		private final Keyword cReferenceNameNUMBER_OF_ELEMENTSKeyword_0_4 = (Keyword)cReferenceNameAlternatives_0.eContents().get(4);
		
		//// VariableReference -> ID
		//VariableReference:
		//	referenceName=('BYTESIZE' | 'VALUE' | 'STRUCTURE' | 'TYPE' | 'NUMBER_OF_ELEMENTS');
		@Override public ParserRule getRule() { return rule; }
		
		//referenceName=('BYTESIZE' | 'VALUE' | 'STRUCTURE' | 'TYPE' | 'NUMBER_OF_ELEMENTS')
		public Assignment getReferenceNameAssignment() { return cReferenceNameAssignment; }
		
		//('BYTESIZE' | 'VALUE' | 'STRUCTURE' | 'TYPE' | 'NUMBER_OF_ELEMENTS')
		public Alternatives getReferenceNameAlternatives_0() { return cReferenceNameAlternatives_0; }
		
		//'BYTESIZE'
		public Keyword getReferenceNameBYTESIZEKeyword_0_0() { return cReferenceNameBYTESIZEKeyword_0_0; }
		
		//'VALUE'
		public Keyword getReferenceNameVALUEKeyword_0_1() { return cReferenceNameVALUEKeyword_0_1; }
		
		//'STRUCTURE'
		public Keyword getReferenceNameSTRUCTUREKeyword_0_2() { return cReferenceNameSTRUCTUREKeyword_0_2; }
		
		//'TYPE'
		public Keyword getReferenceNameTYPEKeyword_0_3() { return cReferenceNameTYPEKeyword_0_3; }
		
		//'NUMBER_OF_ELEMENTS'
		public Keyword getReferenceNameNUMBER_OF_ELEMENTSKeyword_0_4() { return cReferenceNameNUMBER_OF_ELEMENTSKeyword_0_4; }
	}
	public class NamespaceReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.NamespaceReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cReferenceNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cReferenceNameIDTerminalRuleCall_0_0 = (RuleCall)cReferenceNameAssignment_0.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cInnerReference_NamespaceReferenceAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cInnerReference_NamespaceReferenceAbstractNamedReferenceParserRuleCall_2_0_0 = (RuleCall)cInnerReference_NamespaceReferenceAssignment_2_0.eContents().get(0);
		private final Assignment cInnerReference_NamespaceReferenceAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cInnerReference_NamespaceReferenceVariableReferenceParserRuleCall_2_1_0 = (RuleCall)cInnerReference_NamespaceReferenceAssignment_2_1.eContents().get(0);
		
		//// NamespaceReference -> ID '.' AbstractNamedReference
		//NamespaceReference:
		//	referenceName=ID '.' (innerReference_NamespaceReference=AbstractNamedReference
		//	| innerReference_NamespaceReference=VariableReference);
		@Override public ParserRule getRule() { return rule; }
		
		//referenceName=ID '.' (innerReference_NamespaceReference=AbstractNamedReference |
		//innerReference_NamespaceReference=VariableReference)
		public Group getGroup() { return cGroup; }
		
		//referenceName=ID
		public Assignment getReferenceNameAssignment_0() { return cReferenceNameAssignment_0; }
		
		//ID
		public RuleCall getReferenceNameIDTerminalRuleCall_0_0() { return cReferenceNameIDTerminalRuleCall_0_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//(innerReference_NamespaceReference=AbstractNamedReference | innerReference_NamespaceReference=VariableReference)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//innerReference_NamespaceReference=AbstractNamedReference
		public Assignment getInnerReference_NamespaceReferenceAssignment_2_0() { return cInnerReference_NamespaceReferenceAssignment_2_0; }
		
		//AbstractNamedReference
		public RuleCall getInnerReference_NamespaceReferenceAbstractNamedReferenceParserRuleCall_2_0_0() { return cInnerReference_NamespaceReferenceAbstractNamedReferenceParserRuleCall_2_0_0; }
		
		//innerReference_NamespaceReference=VariableReference
		public Assignment getInnerReference_NamespaceReferenceAssignment_2_1() { return cInnerReference_NamespaceReferenceAssignment_2_1; }
		
		//VariableReference
		public RuleCall getInnerReference_NamespaceReferenceVariableReferenceParserRuleCall_2_1_0() { return cInnerReference_NamespaceReferenceVariableReferenceParserRuleCall_2_1_0; }
	}
	public class BoolLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BoolLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEAN_KEYWORDSTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// BoolLiteral -> BOOLEAN_KEYWORDS
		//BoolLiteral:
		//	value=BOOLEAN_KEYWORDS;
		@Override public ParserRule getRule() { return rule; }
		
		//value=BOOLEAN_KEYWORDS
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BOOLEAN_KEYWORDS
		public RuleCall getValueBOOLEAN_KEYWORDSTerminalRuleCall_0() { return cValueBOOLEAN_KEYWORDSTerminalRuleCall_0; }
	}
	public class StringLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.StringLiteral");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//// StringLiteral -> STRING
		//StringLiteral:
		//	value=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class IntLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.IntLiteral");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cValueAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cValueDECINTTerminalRuleCall_0_0 = (RuleCall)cValueAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cUnitAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cUnitUnitParserRuleCall_1_1_0 = (RuleCall)cUnitAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//// IntLiteral -> DECINT ('[' Unit ']')?
		//IntLiteral:
		//	value=DECINT ('[' unit=Unit ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//value=DECINT ('[' unit=Unit ']')?
		public Group getGroup() { return cGroup; }
		
		//value=DECINT
		public Assignment getValueAssignment_0() { return cValueAssignment_0; }
		
		//DECINT
		public RuleCall getValueDECINTTerminalRuleCall_0_0() { return cValueDECINTTerminalRuleCall_0_0; }
		
		//('[' unit=Unit ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//unit=Unit
		public Assignment getUnitAssignment_1_1() { return cUnitAssignment_1_1; }
		
		//Unit
		public RuleCall getUnitUnitParserRuleCall_1_1_0() { return cUnitUnitParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class UnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.Unit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnitMultiParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnitDivParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cBaseUnitParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////#############################
		//// Units:
		//// Unit -> unitMulti | unitDiv | BaseUnit
		//Unit:
		//	unitMulti | unitDiv | BaseUnit;
		@Override public ParserRule getRule() { return rule; }
		
		//unitMulti | unitDiv | BaseUnit
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//unitMulti
		public RuleCall getUnitMultiParserRuleCall_0() { return cUnitMultiParserRuleCall_0; }
		
		//unitDiv
		public RuleCall getUnitDivParserRuleCall_1() { return cUnitDivParserRuleCall_1; }
		
		//BaseUnit
		public RuleCall getBaseUnitParserRuleCall_2() { return cBaseUnitParserRuleCall_2; }
	}
	public class UnitDivElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.unitDiv");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnitPowParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUnitDivisionDividendAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cDivisorAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cDivisorUnitParserRuleCall_1_2_0 = (RuleCall)cDivisorAssignment_1_2.eContents().get(0);
		
		//// unitDiv -> unitPow ('/' Unit)?
		//unitDiv Unit:
		//	unitPow ({UnitDivision.dividend=current} '/' divisor=Unit)?;
		@Override public ParserRule getRule() { return rule; }
		
		//unitPow ({UnitDivision.dividend=current} '/' divisor=Unit)?
		public Group getGroup() { return cGroup; }
		
		//unitPow
		public RuleCall getUnitPowParserRuleCall_0() { return cUnitPowParserRuleCall_0; }
		
		//({UnitDivision.dividend=current} '/' divisor=Unit)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnitDivision.dividend=current}
		public Action getUnitDivisionDividendAction_1_0() { return cUnitDivisionDividendAction_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
		
		//divisor=Unit
		public Assignment getDivisorAssignment_1_2() { return cDivisorAssignment_1_2; }
		
		//Unit
		public RuleCall getDivisorUnitParserRuleCall_1_2_0() { return cDivisorUnitParserRuleCall_1_2_0; }
	}
	public class UnitMultiElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.unitMulti");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnitPowParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUnitMultiplicationUnitsAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cUnitsAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cUnitsUnitParserRuleCall_1_2_0 = (RuleCall)cUnitsAssignment_1_2.eContents().get(0);
		
		//// unitMulti -> unitPow ('*' Unit)*
		//unitMulti Unit:
		//	unitPow ({UnitMultiplication.units+=current} '*' units+=Unit)*;
		@Override public ParserRule getRule() { return rule; }
		
		//unitPow ({UnitMultiplication.units+=current} '*' units+=Unit)*
		public Group getGroup() { return cGroup; }
		
		//unitPow
		public RuleCall getUnitPowParserRuleCall_0() { return cUnitPowParserRuleCall_0; }
		
		//({UnitMultiplication.units+=current} '*' units+=Unit)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnitMultiplication.units+=current}
		public Action getUnitMultiplicationUnitsAction_1_0() { return cUnitMultiplicationUnitsAction_1_0; }
		
		//'*'
		public Keyword getAsteriskKeyword_1_1() { return cAsteriskKeyword_1_1; }
		
		//units+=Unit
		public Assignment getUnitsAssignment_1_2() { return cUnitsAssignment_1_2; }
		
		//Unit
		public RuleCall getUnitsUnitParserRuleCall_1_2_0() { return cUnitsUnitParserRuleCall_1_2_0; }
	}
	public class UnitPowElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.unitPow");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cBaseUnitParserRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final Group cGroup_0_1 = (Group)cAlternatives_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0_1_0 = (Keyword)cGroup_0_1.eContents().get(0);
		private final Alternatives cAlternatives_0_1_1 = (Alternatives)cGroup_0_1.eContents().get(1);
		private final RuleCall cUnitMultiParserRuleCall_0_1_1_0 = (RuleCall)cAlternatives_0_1_1.eContents().get(0);
		private final RuleCall cUnitDivParserRuleCall_0_1_1_1 = (RuleCall)cAlternatives_0_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_1_2 = (Keyword)cGroup_0_1.eContents().get(2);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cUnitPowerUnitAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cCircumflexAccentKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cExponentAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cExponentSIGNED_INTParserRuleCall_1_2_0 = (RuleCall)cExponentAssignment_1_2.eContents().get(0);
		
		//// unitPow -> (BaseUnit | '(' (unitMulti | unitDiv) ')') (POW SIGNED_INT)*
		//unitPow Unit:
		//	(BaseUnit |
		//	'(' (unitMulti | unitDiv) ')') ({UnitPower.unit=current} '^' exponent=SIGNED_INT)*;
		@Override public ParserRule getRule() { return rule; }
		
		//(BaseUnit | '(' (unitMulti | unitDiv) ')') ({UnitPower.unit=current} '^' exponent=SIGNED_INT)*
		public Group getGroup() { return cGroup; }
		
		//(BaseUnit | '(' (unitMulti | unitDiv) ')')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//BaseUnit
		public RuleCall getBaseUnitParserRuleCall_0_0() { return cBaseUnitParserRuleCall_0_0; }
		
		//'(' (unitMulti | unitDiv) ')'
		public Group getGroup_0_1() { return cGroup_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_1_0() { return cLeftParenthesisKeyword_0_1_0; }
		
		//(unitMulti | unitDiv)
		public Alternatives getAlternatives_0_1_1() { return cAlternatives_0_1_1; }
		
		//unitMulti
		public RuleCall getUnitMultiParserRuleCall_0_1_1_0() { return cUnitMultiParserRuleCall_0_1_1_0; }
		
		//unitDiv
		public RuleCall getUnitDivParserRuleCall_0_1_1_1() { return cUnitDivParserRuleCall_0_1_1_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_1_2() { return cRightParenthesisKeyword_0_1_2; }
		
		//({UnitPower.unit=current} '^' exponent=SIGNED_INT)*
		public Group getGroup_1() { return cGroup_1; }
		
		//{UnitPower.unit=current}
		public Action getUnitPowerUnitAction_1_0() { return cUnitPowerUnitAction_1_0; }
		
		//'^'
		public Keyword getCircumflexAccentKeyword_1_1() { return cCircumflexAccentKeyword_1_1; }
		
		//exponent=SIGNED_INT
		public Assignment getExponentAssignment_1_2() { return cExponentAssignment_1_2; }
		
		//SIGNED_INT
		public RuleCall getExponentSIGNED_INTParserRuleCall_1_2_0() { return cExponentSIGNED_INTParserRuleCall_1_2_0; }
	}
	public class BaseUnitElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BaseUnit");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameUnitNamesEnumRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//// BaseUnit -> UnitNames
		//BaseUnit:
		//	name=UnitNames;
		@Override public ParserRule getRule() { return rule; }
		
		//name=UnitNames
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//UnitNames
		public RuleCall getNameUnitNamesEnumRuleCall_0() { return cNameUnitNamesEnumRuleCall_0; }
	}
	public class DefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.definition");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProbabilityMassFunctionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cProbabilityDensityFunctionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////#############################
		////Probability Functions:
		//// definition -> ProbabilityMassFunction | ProbabilityDensityFunction
		//definition ProbabilityFunction:
		//	ProbabilityMassFunction
		//	| ProbabilityDensityFunction;
		@Override public ParserRule getRule() { return rule; }
		
		//ProbabilityMassFunction | ProbabilityDensityFunction
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ProbabilityMassFunction
		public RuleCall getProbabilityMassFunctionParserRuleCall_0() { return cProbabilityMassFunctionParserRuleCall_0; }
		
		//ProbabilityDensityFunction
		public RuleCall getProbabilityDensityFunctionParserRuleCall_1() { return cProbabilityDensityFunctionParserRuleCall_1; }
	}
	public class ProbabilityDensityFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ProbabilityDensityFunction");
		private final RuleCall cBoxedPDFParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//// ProbabilityDensityFunction -> BoxedPDF
		//ProbabilityDensityFunction:
		//	BoxedPDF;
		@Override public ParserRule getRule() { return rule; }
		
		//BoxedPDF
		public RuleCall getBoxedPDFParserRuleCall() { return cBoxedPDFParserRuleCall; }
	}
	public class BoxedPDFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BoxedPDF");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDoublePDFKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSamplesAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSamplesReal_pdf_sampleParserRuleCall_2_0 = (RuleCall)cSamplesAssignment_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cUnitAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cUnitUnitParserRuleCall_4_1_0 = (RuleCall)cUnitAssignment_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		
		//// BoxedPDF -> DOUBLEPDF '[' (real_pdf_sample)+ ']' ('[' Unit ']')?
		//BoxedPDF:
		//	'DoublePDF' '[' samples+=real_pdf_sample+ ']' ('[' unit=Unit ']')?;
		@Override public ParserRule getRule() { return rule; }
		
		//'DoublePDF' '[' samples+=real_pdf_sample+ ']' ('[' unit=Unit ']')?
		public Group getGroup() { return cGroup; }
		
		//'DoublePDF'
		public Keyword getDoublePDFKeyword_0() { return cDoublePDFKeyword_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//samples+=real_pdf_sample+
		public Assignment getSamplesAssignment_2() { return cSamplesAssignment_2; }
		
		//real_pdf_sample
		public RuleCall getSamplesReal_pdf_sampleParserRuleCall_2_0() { return cSamplesReal_pdf_sampleParserRuleCall_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3() { return cRightSquareBracketKeyword_3; }
		
		//('[' unit=Unit ']')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_4_0() { return cLeftSquareBracketKeyword_4_0; }
		
		//unit=Unit
		public Assignment getUnitAssignment_4_1() { return cUnitAssignment_4_1; }
		
		//Unit
		public RuleCall getUnitUnitParserRuleCall_4_1_0() { return cUnitUnitParserRuleCall_4_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4_2() { return cRightSquareBracketKeyword_4_2; }
	}
	public class ProbabilityMassFunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ProbabilityMassFunction");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cIntPMFKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cSamplesAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cSamplesNumeric_int_sampleParserRuleCall_0_2_0 = (RuleCall)cSamplesAssignment_0_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final Group cGroup_0_4 = (Group)cGroup_0.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_0_4_0 = (Keyword)cGroup_0_4.eContents().get(0);
		private final Assignment cUnitAssignment_0_4_1 = (Assignment)cGroup_0_4.eContents().get(1);
		private final RuleCall cUnitUnitParserRuleCall_0_4_1_0 = (RuleCall)cUnitAssignment_0_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_0_4_2 = (Keyword)cGroup_0_4.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cDoublePMFKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cSamplesAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cSamplesNumeric_real_sampleParserRuleCall_1_2_0 = (RuleCall)cSamplesAssignment_1_2.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Group cGroup_1_4 = (Group)cGroup_1.eContents().get(4);
		private final Keyword cLeftSquareBracketKeyword_1_4_0 = (Keyword)cGroup_1_4.eContents().get(0);
		private final Assignment cUnitAssignment_1_4_1 = (Assignment)cGroup_1_4.eContents().get(1);
		private final RuleCall cUnitUnitParserRuleCall_1_4_1_0 = (RuleCall)cUnitAssignment_1_4_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_4_2 = (Keyword)cGroup_1_4.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Keyword cEnumPMFKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cOrderedDomainAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final Keyword cOrderedDomainOrderedKeyword_2_1_1_0 = (Keyword)cOrderedDomainAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_2_1_2 = (Keyword)cGroup_2_1.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		private final Assignment cSamplesAssignment_2_3 = (Assignment)cGroup_2.eContents().get(3);
		private final RuleCall cSamplesStringsampleParserRuleCall_2_3_0 = (RuleCall)cSamplesAssignment_2_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_2_4 = (Keyword)cGroup_2.eContents().get(4);
		private final Group cGroup_3 = (Group)cAlternatives.eContents().get(3);
		private final Keyword cBoolPMFKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cOrderedDomainAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final Keyword cOrderedDomainOrderedKeyword_3_1_1_0 = (Keyword)cOrderedDomainAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3_1_2 = (Keyword)cGroup_3_1.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_3_2 = (Keyword)cGroup_3.eContents().get(2);
		private final Assignment cSamplesAssignment_3_3 = (Assignment)cGroup_3.eContents().get(3);
		private final RuleCall cSamplesBoolsampleParserRuleCall_3_3_0 = (RuleCall)cSamplesAssignment_3_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_3_4 = (Keyword)cGroup_3.eContents().get(4);
		
		//// ProbabilityMassFunction -> INTPMF '[' (numeric_int_sample)+ ']' ('[' Unit ']')?
		//// ProbabilityMassFunction -> DOUBLEPMF '[' (numeric_real_sample)+ ']' ('[' Unit ']')?
		//// ProbabilityMassFunction -> ENUMPMF ('(' 'ordered' ')')? '[' (stringsample)+ ']' ('[' Unit ']')?
		//// ProbabilityMassFunction -> BOOLPMF ('(' 'ordered' ')')? '[' (boolsample)+ ']' ('[' Unit ']')?
		//ProbabilityMassFunction: // Numeric PMF
		//	'IntPMF' '[' samples+=numeric_int_sample+ ']' ('[' unit=Unit ']')? | 'DoublePMF' '[' samples+=numeric_real_sample+ ']'
		//	('[' unit=Unit ']')? | // Enum PMF
		//	'EnumPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=stringsample+ ']' | // Bool PMF
		//	'BoolPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=boolsample+ ']';
		@Override public ParserRule getRule() { return rule; }
		
		//// Numeric PMF
		//'IntPMF' '[' samples+=numeric_int_sample+ ']' ('[' unit=Unit ']')? | 'DoublePMF' '[' samples+=numeric_real_sample+ ']'
		//('[' unit=Unit ']')? | // Enum PMF
		//'EnumPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=stringsample+ ']' | // Bool PMF
		//'BoolPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=boolsample+ ']'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//// Numeric PMF
		//'IntPMF' '[' samples+=numeric_int_sample+ ']' ('[' unit=Unit ']')?
		public Group getGroup_0() { return cGroup_0; }
		
		//// Numeric PMF
		//'IntPMF'
		public Keyword getIntPMFKeyword_0_0() { return cIntPMFKeyword_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0_1() { return cLeftSquareBracketKeyword_0_1; }
		
		//samples+=numeric_int_sample+
		public Assignment getSamplesAssignment_0_2() { return cSamplesAssignment_0_2; }
		
		//numeric_int_sample
		public RuleCall getSamplesNumeric_int_sampleParserRuleCall_0_2_0() { return cSamplesNumeric_int_sampleParserRuleCall_0_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_0_3() { return cRightSquareBracketKeyword_0_3; }
		
		//('[' unit=Unit ']')?
		public Group getGroup_0_4() { return cGroup_0_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_0_4_0() { return cLeftSquareBracketKeyword_0_4_0; }
		
		//unit=Unit
		public Assignment getUnitAssignment_0_4_1() { return cUnitAssignment_0_4_1; }
		
		//Unit
		public RuleCall getUnitUnitParserRuleCall_0_4_1_0() { return cUnitUnitParserRuleCall_0_4_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_0_4_2() { return cRightSquareBracketKeyword_0_4_2; }
		
		//'DoublePMF' '[' samples+=numeric_real_sample+ ']' ('[' unit=Unit ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'DoublePMF'
		public Keyword getDoublePMFKeyword_1_0() { return cDoublePMFKeyword_1_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_1() { return cLeftSquareBracketKeyword_1_1; }
		
		//samples+=numeric_real_sample+
		public Assignment getSamplesAssignment_1_2() { return cSamplesAssignment_1_2; }
		
		//numeric_real_sample
		public RuleCall getSamplesNumeric_real_sampleParserRuleCall_1_2_0() { return cSamplesNumeric_real_sampleParserRuleCall_1_2_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_3() { return cRightSquareBracketKeyword_1_3; }
		
		//('[' unit=Unit ']')?
		public Group getGroup_1_4() { return cGroup_1_4; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_4_0() { return cLeftSquareBracketKeyword_1_4_0; }
		
		//unit=Unit
		public Assignment getUnitAssignment_1_4_1() { return cUnitAssignment_1_4_1; }
		
		//Unit
		public RuleCall getUnitUnitParserRuleCall_1_4_1_0() { return cUnitUnitParserRuleCall_1_4_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_4_2() { return cRightSquareBracketKeyword_1_4_2; }
		
		//// Enum PMF
		//'EnumPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=stringsample+ ']'
		public Group getGroup_2() { return cGroup_2; }
		
		//// Enum PMF
		//'EnumPMF'
		public Keyword getEnumPMFKeyword_2_0() { return cEnumPMFKeyword_2_0; }
		
		//('(' orderedDomain?='ordered' ')')?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2_1_0() { return cLeftParenthesisKeyword_2_1_0; }
		
		//orderedDomain?='ordered'
		public Assignment getOrderedDomainAssignment_2_1_1() { return cOrderedDomainAssignment_2_1_1; }
		
		//'ordered'
		public Keyword getOrderedDomainOrderedKeyword_2_1_1_0() { return cOrderedDomainOrderedKeyword_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2_1_2() { return cRightParenthesisKeyword_2_1_2; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_2_2() { return cLeftSquareBracketKeyword_2_2; }
		
		//samples+=stringsample+
		public Assignment getSamplesAssignment_2_3() { return cSamplesAssignment_2_3; }
		
		//stringsample
		public RuleCall getSamplesStringsampleParserRuleCall_2_3_0() { return cSamplesStringsampleParserRuleCall_2_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_2_4() { return cRightSquareBracketKeyword_2_4; }
		
		//// Bool PMF
		//'BoolPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=boolsample+ ']'
		public Group getGroup_3() { return cGroup_3; }
		
		//// Bool PMF
		//'BoolPMF'
		public Keyword getBoolPMFKeyword_3_0() { return cBoolPMFKeyword_3_0; }
		
		//('(' orderedDomain?='ordered' ')')?
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_3_1_0() { return cLeftParenthesisKeyword_3_1_0; }
		
		//orderedDomain?='ordered'
		public Assignment getOrderedDomainAssignment_3_1_1() { return cOrderedDomainAssignment_3_1_1; }
		
		//'ordered'
		public Keyword getOrderedDomainOrderedKeyword_3_1_1_0() { return cOrderedDomainOrderedKeyword_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3_1_2() { return cRightParenthesisKeyword_3_1_2; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_3_2() { return cLeftSquareBracketKeyword_3_2; }
		
		//samples+=boolsample+
		public Assignment getSamplesAssignment_3_3() { return cSamplesAssignment_3_3; }
		
		//boolsample
		public RuleCall getSamplesBoolsampleParserRuleCall_3_3_0() { return cSamplesBoolsampleParserRuleCall_3_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_3_4() { return cRightSquareBracketKeyword_3_4; }
	}
	public class Numeric_int_sampleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.numeric_int_sample");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSIGNED_INTParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cProbabilityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProbabilityDOUBLETerminalRuleCall_3_0 = (RuleCall)cProbabilityAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// numeric_int_sample -> '(' SIGNED_INT ';' DOUBLE ')'
		//numeric_int_sample IntSample:
		//	'(' value=SIGNED_INT //INT
		//	';' probability=DOUBLE //DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' value=SIGNED_INT //INT
		//';' probability=DOUBLE //DOUBLE
		//')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//value=SIGNED_INT
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//SIGNED_INT
		public RuleCall getValueSIGNED_INTParserRuleCall_1_0() { return cValueSIGNED_INTParserRuleCall_1_0; }
		
		////INT
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//probability=DOUBLE
		public Assignment getProbabilityAssignment_3() { return cProbabilityAssignment_3; }
		
		//DOUBLE
		public RuleCall getProbabilityDOUBLETerminalRuleCall_3_0() { return cProbabilityDOUBLETerminalRuleCall_3_0; }
		
		////DOUBLE
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class Numeric_real_sampleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.numeric_real_sample");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSIGNED_NUMBERParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cProbabilityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProbabilityDOUBLETerminalRuleCall_3_0 = (RuleCall)cProbabilityAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// numeric_real_sample -> '(' SIGNED_NUMBER ';' DOUBLE ')'
		//numeric_real_sample DoubleSample:
		//	'(' value=SIGNED_NUMBER //DOUBLE
		//	';' probability=DOUBLE //DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' value=SIGNED_NUMBER //DOUBLE
		//';' probability=DOUBLE //DOUBLE
		//')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//value=SIGNED_NUMBER
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//SIGNED_NUMBER
		public RuleCall getValueSIGNED_NUMBERParserRuleCall_1_0() { return cValueSIGNED_NUMBERParserRuleCall_1_0; }
		
		////DOUBLE
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//probability=DOUBLE
		public Assignment getProbabilityAssignment_3() { return cProbabilityAssignment_3; }
		
		//DOUBLE
		public RuleCall getProbabilityDOUBLETerminalRuleCall_3_0() { return cProbabilityDOUBLETerminalRuleCall_3_0; }
		
		////DOUBLE
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class Real_pdf_sampleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.real_pdf_sample");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSIGNED_NUMBERParserRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cProbabilityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProbabilityDOUBLETerminalRuleCall_3_0 = (RuleCall)cProbabilityAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// real_pdf_sample -> '(' SIGNED_NUMBER ';' DOUBLE ')'		
		//real_pdf_sample ContinuousSample:
		//	'(' value=SIGNED_NUMBER //DOUBLE
		//	';' probability=DOUBLE //DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' value=SIGNED_NUMBER //DOUBLE
		//';' probability=DOUBLE //DOUBLE
		//')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//value=SIGNED_NUMBER
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//SIGNED_NUMBER
		public RuleCall getValueSIGNED_NUMBERParserRuleCall_1_0() { return cValueSIGNED_NUMBERParserRuleCall_1_0; }
		
		////DOUBLE
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//probability=DOUBLE
		public Assignment getProbabilityAssignment_3() { return cProbabilityAssignment_3; }
		
		//DOUBLE
		public RuleCall getProbabilityDOUBLETerminalRuleCall_3_0() { return cProbabilityDOUBLETerminalRuleCall_3_0; }
		
		////DOUBLE
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class StringsampleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.stringsample");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cProbabilityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProbabilityDOUBLETerminalRuleCall_3_0 = (RuleCall)cProbabilityAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// stringsample -> '(' STRING ';' DOUBLE ')'		
		//stringsample StringSample:
		//	'(' value=STRING ';' probability=DOUBLE //DOUBLE
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' value=STRING ';' probability=DOUBLE //DOUBLE
		//')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//value=STRING
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_1_0() { return cValueSTRINGTerminalRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//probability=DOUBLE
		public Assignment getProbabilityAssignment_3() { return cProbabilityAssignment_3; }
		
		//DOUBLE
		public RuleCall getProbabilityDOUBLETerminalRuleCall_3_0() { return cProbabilityDOUBLETerminalRuleCall_3_0; }
		
		////DOUBLE
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class BoolsampleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.boolsample");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cValueAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cValueBOOLEAN_KEYWORDSTerminalRuleCall_1_0 = (RuleCall)cValueAssignment_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cProbabilityAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cProbabilityDOUBLETerminalRuleCall_3_0 = (RuleCall)cProbabilityAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//// boolsample -> '(' BOOLEAN_KEYWORDS ';' DOUBLE ')'
		//boolsample BoolSample:
		//	'(' value=BOOLEAN_KEYWORDS ';' probability=DOUBLE //DOUBLE 
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//'(' value=BOOLEAN_KEYWORDS ';' probability=DOUBLE //DOUBLE 
		//')'
		public Group getGroup() { return cGroup; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//value=BOOLEAN_KEYWORDS
		public Assignment getValueAssignment_1() { return cValueAssignment_1; }
		
		//BOOLEAN_KEYWORDS
		public RuleCall getValueBOOLEAN_KEYWORDSTerminalRuleCall_1_0() { return cValueBOOLEAN_KEYWORDSTerminalRuleCall_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//probability=DOUBLE
		public Assignment getProbabilityAssignment_3() { return cProbabilityAssignment_3; }
		
		//DOUBLE
		public RuleCall getProbabilityDOUBLETerminalRuleCall_3_0() { return cProbabilityDOUBLETerminalRuleCall_3_0; }
		
		////DOUBLE 
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class SIGNED_NUMBERElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.SIGNED_NUMBER");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDOUBLETerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////#############################
		//// Datatype rules/terminals:
		//// SIGNED_NUMBER -> ('-')? DOUBLE
		//SIGNED_NUMBER ecore::EDouble:
		//	'-'? DOUBLE;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? DOUBLE
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//DOUBLE
		public RuleCall getDOUBLETerminalRuleCall_1() { return cDOUBLETerminalRuleCall_1; }
	}
	public class SIGNED_INTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.SIGNED_INT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDECINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//// SIGNED_INT -> ('-')? DECINT
		//SIGNED_INT ecore::EInt:
		//	'-'? DECINT;
		@Override public ParserRule getRule() { return rule; }
		
		//'-'? DECINT
		public Group getGroup() { return cGroup; }
		
		//'-'?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }
		
		//DECINT
		public RuleCall getDECINTTerminalRuleCall_1() { return cDECINTTerminalRuleCall_1; }
	}
	
	public class BooleanOperationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BooleanOperations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cANDANDKeyword_0_0 = (Keyword)cANDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cORORKeyword_1_0 = (Keyword)cOREnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cXORXORKeyword_2_0 = (Keyword)cXOREnumLiteralDeclaration_2.eContents().get(0);
		
		//enum BooleanOperations:
		//	AND | OR | XOR;
		public EnumRule getRule() { return rule; }
		
		//AND | OR | XOR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AND
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration_0() { return cANDEnumLiteralDeclaration_0; }
		
		//"AND"
		public Keyword getANDANDKeyword_0_0() { return cANDANDKeyword_0_0; }
		
		//OR
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_1() { return cOREnumLiteralDeclaration_1; }
		
		//"OR"
		public Keyword getORORKeyword_1_0() { return cORORKeyword_1_0; }
		
		//XOR
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_2() { return cXOREnumLiteralDeclaration_2; }
		
		//"XOR"
		public Keyword getXORXORKeyword_2_0() { return cXORXORKeyword_2_0; }
	}
	public class AndoperationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.andoperation");
		private final EnumLiteralDeclaration cANDEnumLiteralDeclaration = (EnumLiteralDeclaration)rule.eContents().get(1);
		private final Keyword cANDANDKeyword_0 = (Keyword)cANDEnumLiteralDeclaration.eContents().get(0);
		
		//enum andoperation returns BooleanOperations:
		//	AND;
		public EnumRule getRule() { return rule; }
		
		//AND
		public EnumLiteralDeclaration getANDEnumLiteralDeclaration() { return cANDEnumLiteralDeclaration; }
		
		//"AND"
		public Keyword getANDANDKeyword_0() { return cANDANDKeyword_0; }
	}
	public class OroperationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.oroperations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cOREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cORORKeyword_0_0 = (Keyword)cOREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cXOREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cXORXORKeyword_1_0 = (Keyword)cXOREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum oroperations returns BooleanOperations:
		//	OR | XOR;
		public EnumRule getRule() { return rule; }
		
		//OR | XOR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//OR
		public EnumLiteralDeclaration getOREnumLiteralDeclaration_0() { return cOREnumLiteralDeclaration_0; }
		
		//"OR"
		public Keyword getORORKeyword_0_0() { return cORORKeyword_0_0; }
		
		//XOR
		public EnumLiteralDeclaration getXOREnumLiteralDeclaration_1() { return cXOREnumLiteralDeclaration_1; }
		
		//"XOR"
		public Keyword getXORXORKeyword_1_0() { return cXORXORKeyword_1_0; }
	}
	public class CompareOperationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.CompareOperations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cGREATEREnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cGREATERGreaterThanSignKeyword_0_0 = (Keyword)cGREATEREnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLESSLessThanSignKeyword_1_0 = (Keyword)cLESSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cEQUALSEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cEQUALSEqualsSignEqualsSignKeyword_2_0 = (Keyword)cEQUALSEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cNOTEQUALEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cNOTEQUALLessThanSignGreaterThanSignKeyword_3_0 = (Keyword)cNOTEQUALEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGREATEREQUALEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGREATEREQUALGreaterThanSignEqualsSignKeyword_4_0 = (Keyword)cGREATEREQUALEnumLiteralDeclaration_4.eContents().get(0);
		private final EnumLiteralDeclaration cLESSEQUALEnumLiteralDeclaration_5 = (EnumLiteralDeclaration)cAlternatives.eContents().get(5);
		private final Keyword cLESSEQUALLessThanSignEqualsSignKeyword_5_0 = (Keyword)cLESSEQUALEnumLiteralDeclaration_5.eContents().get(0);
		
		//enum CompareOperations:
		//	GREATER='>' | LESS='<' | EQUALS='==' | NOTEQUAL='<>' | GREATEREQUAL='>=' | LESSEQUAL='<=';
		public EnumRule getRule() { return rule; }
		
		//GREATER='>' | LESS='<' | EQUALS='==' | NOTEQUAL='<>' | GREATEREQUAL='>=' | LESSEQUAL='<='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GREATER='>'
		public EnumLiteralDeclaration getGREATEREnumLiteralDeclaration_0() { return cGREATEREnumLiteralDeclaration_0; }
		
		//'>'
		public Keyword getGREATERGreaterThanSignKeyword_0_0() { return cGREATERGreaterThanSignKeyword_0_0; }
		
		//LESS='<'
		public EnumLiteralDeclaration getLESSEnumLiteralDeclaration_1() { return cLESSEnumLiteralDeclaration_1; }
		
		//'<'
		public Keyword getLESSLessThanSignKeyword_1_0() { return cLESSLessThanSignKeyword_1_0; }
		
		//EQUALS='=='
		public EnumLiteralDeclaration getEQUALSEnumLiteralDeclaration_2() { return cEQUALSEnumLiteralDeclaration_2; }
		
		//'=='
		public Keyword getEQUALSEqualsSignEqualsSignKeyword_2_0() { return cEQUALSEqualsSignEqualsSignKeyword_2_0; }
		
		//NOTEQUAL='<>'
		public EnumLiteralDeclaration getNOTEQUALEnumLiteralDeclaration_3() { return cNOTEQUALEnumLiteralDeclaration_3; }
		
		//'<>'
		public Keyword getNOTEQUALLessThanSignGreaterThanSignKeyword_3_0() { return cNOTEQUALLessThanSignGreaterThanSignKeyword_3_0; }
		
		//GREATEREQUAL='>='
		public EnumLiteralDeclaration getGREATEREQUALEnumLiteralDeclaration_4() { return cGREATEREQUALEnumLiteralDeclaration_4; }
		
		//'>='
		public Keyword getGREATEREQUALGreaterThanSignEqualsSignKeyword_4_0() { return cGREATEREQUALGreaterThanSignEqualsSignKeyword_4_0; }
		
		//LESSEQUAL='<='
		public EnumLiteralDeclaration getLESSEQUALEnumLiteralDeclaration_5() { return cLESSEQUALEnumLiteralDeclaration_5; }
		
		//'<='
		public Keyword getLESSEQUALLessThanSignEqualsSignKeyword_5_0() { return cLESSEQUALLessThanSignEqualsSignKeyword_5_0; }
	}
	public class TermOperationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.TermOperations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cADDEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cADDPlusSignKeyword_0_0 = (Keyword)cADDEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSUBEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSUBHyphenMinusKeyword_1_0 = (Keyword)cSUBEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum TermOperations:
		//	ADD="+" | SUB="-";
		public EnumRule getRule() { return rule; }
		
		//ADD="+" | SUB="-"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ADD="+"
		public EnumLiteralDeclaration getADDEnumLiteralDeclaration_0() { return cADDEnumLiteralDeclaration_0; }
		
		//"+"
		public Keyword getADDPlusSignKeyword_0_0() { return cADDPlusSignKeyword_0_0; }
		
		//SUB="-"
		public EnumLiteralDeclaration getSUBEnumLiteralDeclaration_1() { return cSUBEnumLiteralDeclaration_1; }
		
		//"-"
		public Keyword getSUBHyphenMinusKeyword_1_0() { return cSUBHyphenMinusKeyword_1_0; }
	}
	public class ProductOperationsElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ProductOperations");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMULTEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMULTAsteriskKeyword_0_0 = (Keyword)cMULTEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDIVEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDIVSolidusKeyword_1_0 = (Keyword)cDIVEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cMODEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cMODPercentSignKeyword_2_0 = (Keyword)cMODEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ProductOperations:
		//	MULT="*" | DIV="/" | MOD="%";
		public EnumRule getRule() { return rule; }
		
		//MULT="*" | DIV="/" | MOD="%"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//MULT="*"
		public EnumLiteralDeclaration getMULTEnumLiteralDeclaration_0() { return cMULTEnumLiteralDeclaration_0; }
		
		//"*"
		public Keyword getMULTAsteriskKeyword_0_0() { return cMULTAsteriskKeyword_0_0; }
		
		//DIV="/"
		public EnumLiteralDeclaration getDIVEnumLiteralDeclaration_1() { return cDIVEnumLiteralDeclaration_1; }
		
		//"/"
		public Keyword getDIVSolidusKeyword_1_0() { return cDIVSolidusKeyword_1_0; }
		
		//MOD="%"
		public EnumLiteralDeclaration getMODEnumLiteralDeclaration_2() { return cMODEnumLiteralDeclaration_2; }
		
		//"%"
		public Keyword getMODPercentSignKeyword_2_0() { return cMODPercentSignKeyword_2_0; }
	}
	public class UnitNamesElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.UnitNames");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cUNITLESSEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cUNITLESS_Keyword_0_0 = (Keyword)cUNITLESSEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUNITLESSEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUNITLESSUnitlessKeyword_1_0 = (Keyword)cUNITLESSEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cBYTEEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cBYTEBKeyword_2_0 = (Keyword)cBYTEEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cSECONDEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cSECONDSKeyword_3_0 = (Keyword)cSECONDEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cMETEREnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cMETERMKeyword_4_0 = (Keyword)cMETEREnumLiteralDeclaration_4.eContents().get(0);
		
		//enum UnitNames:
		//	UNITLESS="_" | UNITLESS="unitless" | BYTE="B" | SECOND="s" | METER="m";
		public EnumRule getRule() { return rule; }
		
		//UNITLESS="_" | UNITLESS="unitless" | BYTE="B" | SECOND="s" | METER="m"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//UNITLESS="_"
		public EnumLiteralDeclaration getUNITLESSEnumLiteralDeclaration_0() { return cUNITLESSEnumLiteralDeclaration_0; }
		
		//"_"
		public Keyword getUNITLESS_Keyword_0_0() { return cUNITLESS_Keyword_0_0; }
		
		//UNITLESS="unitless"
		public EnumLiteralDeclaration getUNITLESSEnumLiteralDeclaration_1() { return cUNITLESSEnumLiteralDeclaration_1; }
		
		//"unitless"
		public Keyword getUNITLESSUnitlessKeyword_1_0() { return cUNITLESSUnitlessKeyword_1_0; }
		
		//BYTE="B"
		public EnumLiteralDeclaration getBYTEEnumLiteralDeclaration_2() { return cBYTEEnumLiteralDeclaration_2; }
		
		//"B"
		public Keyword getBYTEBKeyword_2_0() { return cBYTEBKeyword_2_0; }
		
		//SECOND="s"
		public EnumLiteralDeclaration getSECONDEnumLiteralDeclaration_3() { return cSECONDEnumLiteralDeclaration_3; }
		
		//"s"
		public Keyword getSECONDSKeyword_3_0() { return cSECONDSKeyword_3_0; }
		
		//METER="m"
		public EnumLiteralDeclaration getMETEREnumLiteralDeclaration_4() { return cMETEREnumLiteralDeclaration_4; }
		
		//"m"
		public Keyword getMETERMKeyword_4_0() { return cMETERMKeyword_4_0; }
	}
	
	private final ExpressionElements pExpression;
	private final IfelseExprElements pIfelseExpr;
	private final BooleanExpressionElements pBooleanExpression;
	private final BooleanOperationsElements eBooleanOperations;
	private final BoolAndExprElements pBoolAndExpr;
	private final AndoperationElements eAndoperation;
	private final BoolOrExprElements pBoolOrExpr;
	private final OroperationsElements eOroperations;
	private final CompareExprElements pCompareExpr;
	private final CompareOperationsElements eCompareOperations;
	private final SumExprElements pSumExpr;
	private final TermOperationsElements eTermOperations;
	private final ProdExprElements pProdExpr;
	private final ProductOperationsElements eProductOperations;
	private final PowExprElements pPowExpr;
	private final UnaryExprElements pUnaryExpr;
	private final NotExpressionElements pNotExpression;
	private final NegativeExpressionElements pNegativeExpression;
	private final AtomElements pAtom;
	private final DoubleLiteralElements pDoubleLiteral;
	private final ProbabilityFunctionLiteralElements pProbabilityFunctionLiteral;
	private final ParenthesisElements pParenthesis;
	private final FunctionLiteralElements pFunctionLiteral;
	private final VariableElements pVariable;
	private final AbstractNamedReferenceElements pAbstractNamedReference;
	private final VariableReferenceElements pVariableReference;
	private final NamespaceReferenceElements pNamespaceReference;
	private final BoolLiteralElements pBoolLiteral;
	private final StringLiteralElements pStringLiteral;
	private final IntLiteralElements pIntLiteral;
	private final UnitElements pUnit;
	private final UnitDivElements pUnitDiv;
	private final UnitMultiElements pUnitMulti;
	private final UnitPowElements pUnitPow;
	private final BaseUnitElements pBaseUnit;
	private final UnitNamesElements eUnitNames;
	private final DefinitionElements pDefinition;
	private final ProbabilityDensityFunctionElements pProbabilityDensityFunction;
	private final BoxedPDFElements pBoxedPDF;
	private final ProbabilityMassFunctionElements pProbabilityMassFunction;
	private final Numeric_int_sampleElements pNumeric_int_sample;
	private final Numeric_real_sampleElements pNumeric_real_sample;
	private final Real_pdf_sampleElements pReal_pdf_sample;
	private final StringsampleElements pStringsample;
	private final BoolsampleElements pBoolsample;
	private final SIGNED_NUMBERElements pSIGNED_NUMBER;
	private final SIGNED_INTElements pSIGNED_INT;
	private final TerminalRule tDOUBLE;
	private final TerminalRule tDECINT;
	private final TerminalRule tBOOLEAN_KEYWORDS;
	private final TerminalRule tDIGIT;
	private final TerminalRule tID;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tANY_OTHER;
	
	private final Grammar grammar;

	@Inject
	public StoexGrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pExpression = new ExpressionElements();
		this.pIfelseExpr = new IfelseExprElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.eBooleanOperations = new BooleanOperationsElements();
		this.pBoolAndExpr = new BoolAndExprElements();
		this.eAndoperation = new AndoperationElements();
		this.pBoolOrExpr = new BoolOrExprElements();
		this.eOroperations = new OroperationsElements();
		this.pCompareExpr = new CompareExprElements();
		this.eCompareOperations = new CompareOperationsElements();
		this.pSumExpr = new SumExprElements();
		this.eTermOperations = new TermOperationsElements();
		this.pProdExpr = new ProdExprElements();
		this.eProductOperations = new ProductOperationsElements();
		this.pPowExpr = new PowExprElements();
		this.pUnaryExpr = new UnaryExprElements();
		this.pNotExpression = new NotExpressionElements();
		this.pNegativeExpression = new NegativeExpressionElements();
		this.pAtom = new AtomElements();
		this.pDoubleLiteral = new DoubleLiteralElements();
		this.pProbabilityFunctionLiteral = new ProbabilityFunctionLiteralElements();
		this.pParenthesis = new ParenthesisElements();
		this.pFunctionLiteral = new FunctionLiteralElements();
		this.pVariable = new VariableElements();
		this.pAbstractNamedReference = new AbstractNamedReferenceElements();
		this.pVariableReference = new VariableReferenceElements();
		this.pNamespaceReference = new NamespaceReferenceElements();
		this.pBoolLiteral = new BoolLiteralElements();
		this.pStringLiteral = new StringLiteralElements();
		this.pIntLiteral = new IntLiteralElements();
		this.pUnit = new UnitElements();
		this.pUnitDiv = new UnitDivElements();
		this.pUnitMulti = new UnitMultiElements();
		this.pUnitPow = new UnitPowElements();
		this.pBaseUnit = new BaseUnitElements();
		this.eUnitNames = new UnitNamesElements();
		this.pDefinition = new DefinitionElements();
		this.pProbabilityDensityFunction = new ProbabilityDensityFunctionElements();
		this.pBoxedPDF = new BoxedPDFElements();
		this.pProbabilityMassFunction = new ProbabilityMassFunctionElements();
		this.pNumeric_int_sample = new Numeric_int_sampleElements();
		this.pNumeric_real_sample = new Numeric_real_sampleElements();
		this.pReal_pdf_sample = new Real_pdf_sampleElements();
		this.pStringsample = new StringsampleElements();
		this.pBoolsample = new BoolsampleElements();
		this.pSIGNED_NUMBER = new SIGNED_NUMBERElements();
		this.pSIGNED_INT = new SIGNED_INTElements();
		this.tDOUBLE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.DOUBLE");
		this.tDECINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.DECINT");
		this.tBOOLEAN_KEYWORDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.BOOLEAN_KEYWORDS");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.DIGIT");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ID");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.WS");
		this.tANY_OTHER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.commons.stoex.Stoex.ANY_OTHER");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.palladiosimulator.commons.stoex.Stoex".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	////#############################
	//// start-rule:
	//// expression -> ifelseExpr
	//expression Expression:
	//	ifelseExpr;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	////#############################
	//// Stochastic Expressions:
	//// ifelseExpr -> boolAndExpr ('?' boolAndExpr ':' boolAndExpr)?
	//ifelseExpr IfElse:
	//	boolAndExpr ({IfElseExpression.conditionExpression=current} '?' ifExpression=boolAndExpr ':'
	//	elseExpression=boolAndExpr)?;
	public IfelseExprElements getIfelseExprAccess() {
		return pIfelseExpr;
	}
	
	public ParserRule getIfelseExprRule() {
		return getIfelseExprAccess().getRule();
	}
	
	////BooleanExpression -> boolOrExpr (BooleanOperations boolOrExpr)*
	//// Note: This is a workaround for the serializer to work with AND-Operations!
	//BooleanExpression:
	//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=BooleanOperations right=boolOrExpr)*;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	//enum BooleanOperations:
	//	AND | OR | XOR;
	public BooleanOperationsElements getBooleanOperationsAccess() {
		return eBooleanOperations;
	}
	
	public EnumRule getBooleanOperationsRule() {
		return getBooleanOperationsAccess().getRule();
	}
	
	//// boolAndExpr -> boolOrExpr (andoperation boolOrExpr)*
	//boolAndExpr BooleanExpression:
	//	boolOrExpr ({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*;
	public BoolAndExprElements getBoolAndExprAccess() {
		return pBoolAndExpr;
	}
	
	public ParserRule getBoolAndExprRule() {
		return getBoolAndExprAccess().getRule();
	}
	
	//enum andoperation returns BooleanOperations:
	//	AND;
	public AndoperationElements getAndoperationAccess() {
		return eAndoperation;
	}
	
	public EnumRule getAndoperationRule() {
		return getAndoperationAccess().getRule();
	}
	
	//// boolOrExpr -> compareExpr (oroperations compareExpr)*
	//boolOrExpr BooleanExpression:
	//	compareExpr ({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*;
	public BoolOrExprElements getBoolOrExprAccess() {
		return pBoolOrExpr;
	}
	
	public ParserRule getBoolOrExprRule() {
		return getBoolOrExprAccess().getRule();
	}
	
	//enum oroperations returns BooleanOperations:
	//	OR | XOR;
	public OroperationsElements getOroperationsAccess() {
		return eOroperations;
	}
	
	public EnumRule getOroperationsRule() {
		return getOroperationsAccess().getRule();
	}
	
	//// compareExpr -> sumExpr (CompareOperations sumExpr)?
	//compareExpr Comparison:
	//	sumExpr ({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?;
	public CompareExprElements getCompareExprAccess() {
		return pCompareExpr;
	}
	
	public ParserRule getCompareExprRule() {
		return getCompareExprAccess().getRule();
	}
	
	//enum CompareOperations:
	//	GREATER='>' | LESS='<' | EQUALS='==' | NOTEQUAL='<>' | GREATEREQUAL='>=' | LESSEQUAL='<=';
	public CompareOperationsElements getCompareOperationsAccess() {
		return eCompareOperations;
	}
	
	public EnumRule getCompareOperationsRule() {
		return getCompareOperationsAccess().getRule();
	}
	
	//// sumExpr -> prodExpr (TermOperations prodExpr)*
	//sumExpr Term:
	//	prodExpr ({TermExpression.left=current} operation=TermOperations right=prodExpr)*;
	public SumExprElements getSumExprAccess() {
		return pSumExpr;
	}
	
	public ParserRule getSumExprRule() {
		return getSumExprAccess().getRule();
	}
	
	//enum TermOperations:
	//	ADD="+" | SUB="-";
	public TermOperationsElements getTermOperationsAccess() {
		return eTermOperations;
	}
	
	public EnumRule getTermOperationsRule() {
		return getTermOperationsAccess().getRule();
	}
	
	//// prodExpr -> powExpr (ProductOperations powExpr)*
	//prodExpr Product:
	//	powExpr ({ProductExpression.left=current} operation=ProductOperations right=powExpr)*;
	public ProdExprElements getProdExprAccess() {
		return pProdExpr;
	}
	
	public ParserRule getProdExprRule() {
		return getProdExprAccess().getRule();
	}
	
	//enum ProductOperations:
	//	MULT="*" | DIV="/" | MOD="%";
	public ProductOperationsElements getProductOperationsAccess() {
		return eProductOperations;
	}
	
	public EnumRule getProductOperationsRule() {
		return getProductOperationsAccess().getRule();
	}
	
	//// powExpr -> unaryExpr (POW unaryExpr)?
	//powExpr Power:
	//	unaryExpr ({PowerExpression.base=current} '^' exponent=unaryExpr)?;
	public PowExprElements getPowExprAccess() {
		return pPowExpr;
	}
	
	public ParserRule getPowExprRule() {
		return getPowExprAccess().getRule();
	}
	
	//// unaryExpr -> NegativeExpression | NotExpression | atom
	//unaryExpr Unary:
	//	NegativeExpression | NotExpression | atom;
	public UnaryExprElements getUnaryExprAccess() {
		return pUnaryExpr;
	}
	
	public ParserRule getUnaryExprRule() {
		return getUnaryExprAccess().getRule();
	}
	
	//// NotExpression -> NOT unaryExpr
	//NotExpression:
	//	'NOT' inner=unaryExpr;
	public NotExpressionElements getNotExpressionAccess() {
		return pNotExpression;
	}
	
	public ParserRule getNotExpressionRule() {
		return getNotExpressionAccess().getRule();
	}
	
	//// NegativeExpression -> '-' unaryExpr
	//NegativeExpression:
	//	'-' inner=unaryExpr;
	public NegativeExpressionElements getNegativeExpressionAccess() {
		return pNegativeExpression;
	}
	
	public ParserRule getNegativeExpressionRule() {
		return getNegativeExpressionAccess().getRule();
	}
	
	//// atom -> 	IntLiteral | DoubleLiteral |StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis | ProbabilityFunctionLiteral
	//atom Atom:
	//	IntLiteral | DoubleLiteral | StringLiteral | BoolLiteral | FunctionLiteral | Variable | Parenthesis |
	//	ProbabilityFunctionLiteral;
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}
	
	//// DoubleLiteral -> DOUBLE ('[' Unit ']')?
	//DoubleLiteral:
	//	value=DOUBLE ('[' unit=Unit ']')?;
	public DoubleLiteralElements getDoubleLiteralAccess() {
		return pDoubleLiteral;
	}
	
	public ParserRule getDoubleLiteralRule() {
		return getDoubleLiteralAccess().getRule();
	}
	
	//// ProbabilityFunctionLiteral -> definition
	//ProbabilityFunctionLiteral:
	//	function_ProbabilityFunctionLiteral=definition;
	public ProbabilityFunctionLiteralElements getProbabilityFunctionLiteralAccess() {
		return pProbabilityFunctionLiteral;
	}
	
	public ParserRule getProbabilityFunctionLiteralRule() {
		return getProbabilityFunctionLiteralAccess().getRule();
	}
	
	//// Parenthesis -> '(' ifelseExpr ')'
	//Parenthesis:
	//	'(' innerExpression=ifelseExpr ')';
	public ParenthesisElements getParenthesisAccess() {
		return pParenthesis;
	}
	
	public ParserRule getParenthesisRule() {
		return getParenthesisAccess().getRule();
	}
	
	//// FunctionLiteral -> ID '(' (boolAndExpr (',' boolAndExpr)* )? ')'
	//FunctionLiteral:
	//	id=ID '(' (parameters_FunctionLiteral+=boolAndExpr (',' parameters_FunctionLiteral+=boolAndExpr)*)? ')';
	public FunctionLiteralElements getFunctionLiteralAccess() {
		return pFunctionLiteral;
	}
	
	public ParserRule getFunctionLiteralRule() {
		return getFunctionLiteralAccess().getRule();
	}
	
	//// Variable -> AbstractNamedReference
	//Variable:
	//	id_Variable=AbstractNamedReference;
	public VariableElements getVariableAccess() {
		return pVariable;
	}
	
	public ParserRule getVariableRule() {
		return getVariableAccess().getRule();
	}
	
	//// AbstractNamedReference -> VariableReference|NamespaceReference
	//AbstractNamedReference:
	//	NamespaceReference;
	public AbstractNamedReferenceElements getAbstractNamedReferenceAccess() {
		return pAbstractNamedReference;
	}
	
	public ParserRule getAbstractNamedReferenceRule() {
		return getAbstractNamedReferenceAccess().getRule();
	}
	
	//// VariableReference -> ID
	//VariableReference:
	//	referenceName=('BYTESIZE' | 'VALUE' | 'STRUCTURE' | 'TYPE' | 'NUMBER_OF_ELEMENTS');
	public VariableReferenceElements getVariableReferenceAccess() {
		return pVariableReference;
	}
	
	public ParserRule getVariableReferenceRule() {
		return getVariableReferenceAccess().getRule();
	}
	
	//// NamespaceReference -> ID '.' AbstractNamedReference
	//NamespaceReference:
	//	referenceName=ID '.' (innerReference_NamespaceReference=AbstractNamedReference
	//	| innerReference_NamespaceReference=VariableReference);
	public NamespaceReferenceElements getNamespaceReferenceAccess() {
		return pNamespaceReference;
	}
	
	public ParserRule getNamespaceReferenceRule() {
		return getNamespaceReferenceAccess().getRule();
	}
	
	//// BoolLiteral -> BOOLEAN_KEYWORDS
	//BoolLiteral:
	//	value=BOOLEAN_KEYWORDS;
	public BoolLiteralElements getBoolLiteralAccess() {
		return pBoolLiteral;
	}
	
	public ParserRule getBoolLiteralRule() {
		return getBoolLiteralAccess().getRule();
	}
	
	//// StringLiteral -> STRING
	//StringLiteral:
	//	value=STRING;
	public StringLiteralElements getStringLiteralAccess() {
		return pStringLiteral;
	}
	
	public ParserRule getStringLiteralRule() {
		return getStringLiteralAccess().getRule();
	}
	
	//// IntLiteral -> DECINT ('[' Unit ']')?
	//IntLiteral:
	//	value=DECINT ('[' unit=Unit ']')?;
	public IntLiteralElements getIntLiteralAccess() {
		return pIntLiteral;
	}
	
	public ParserRule getIntLiteralRule() {
		return getIntLiteralAccess().getRule();
	}
	
	////#############################
	//// Units:
	//// Unit -> unitMulti | unitDiv | BaseUnit
	//Unit:
	//	unitMulti | unitDiv | BaseUnit;
	public UnitElements getUnitAccess() {
		return pUnit;
	}
	
	public ParserRule getUnitRule() {
		return getUnitAccess().getRule();
	}
	
	//// unitDiv -> unitPow ('/' Unit)?
	//unitDiv Unit:
	//	unitPow ({UnitDivision.dividend=current} '/' divisor=Unit)?;
	public UnitDivElements getUnitDivAccess() {
		return pUnitDiv;
	}
	
	public ParserRule getUnitDivRule() {
		return getUnitDivAccess().getRule();
	}
	
	//// unitMulti -> unitPow ('*' Unit)*
	//unitMulti Unit:
	//	unitPow ({UnitMultiplication.units+=current} '*' units+=Unit)*;
	public UnitMultiElements getUnitMultiAccess() {
		return pUnitMulti;
	}
	
	public ParserRule getUnitMultiRule() {
		return getUnitMultiAccess().getRule();
	}
	
	//// unitPow -> (BaseUnit | '(' (unitMulti | unitDiv) ')') (POW SIGNED_INT)*
	//unitPow Unit:
	//	(BaseUnit |
	//	'(' (unitMulti | unitDiv) ')') ({UnitPower.unit=current} '^' exponent=SIGNED_INT)*;
	public UnitPowElements getUnitPowAccess() {
		return pUnitPow;
	}
	
	public ParserRule getUnitPowRule() {
		return getUnitPowAccess().getRule();
	}
	
	//// BaseUnit -> UnitNames
	//BaseUnit:
	//	name=UnitNames;
	public BaseUnitElements getBaseUnitAccess() {
		return pBaseUnit;
	}
	
	public ParserRule getBaseUnitRule() {
		return getBaseUnitAccess().getRule();
	}
	
	//enum UnitNames:
	//	UNITLESS="_" | UNITLESS="unitless" | BYTE="B" | SECOND="s" | METER="m";
	public UnitNamesElements getUnitNamesAccess() {
		return eUnitNames;
	}
	
	public EnumRule getUnitNamesRule() {
		return getUnitNamesAccess().getRule();
	}
	
	////#############################
	////Probability Functions:
	//// definition -> ProbabilityMassFunction | ProbabilityDensityFunction
	//definition ProbabilityFunction:
	//	ProbabilityMassFunction
	//	| ProbabilityDensityFunction;
	public DefinitionElements getDefinitionAccess() {
		return pDefinition;
	}
	
	public ParserRule getDefinitionRule() {
		return getDefinitionAccess().getRule();
	}
	
	//// ProbabilityDensityFunction -> BoxedPDF
	//ProbabilityDensityFunction:
	//	BoxedPDF;
	public ProbabilityDensityFunctionElements getProbabilityDensityFunctionAccess() {
		return pProbabilityDensityFunction;
	}
	
	public ParserRule getProbabilityDensityFunctionRule() {
		return getProbabilityDensityFunctionAccess().getRule();
	}
	
	//// BoxedPDF -> DOUBLEPDF '[' (real_pdf_sample)+ ']' ('[' Unit ']')?
	//BoxedPDF:
	//	'DoublePDF' '[' samples+=real_pdf_sample+ ']' ('[' unit=Unit ']')?;
	public BoxedPDFElements getBoxedPDFAccess() {
		return pBoxedPDF;
	}
	
	public ParserRule getBoxedPDFRule() {
		return getBoxedPDFAccess().getRule();
	}
	
	//// ProbabilityMassFunction -> INTPMF '[' (numeric_int_sample)+ ']' ('[' Unit ']')?
	//// ProbabilityMassFunction -> DOUBLEPMF '[' (numeric_real_sample)+ ']' ('[' Unit ']')?
	//// ProbabilityMassFunction -> ENUMPMF ('(' 'ordered' ')')? '[' (stringsample)+ ']' ('[' Unit ']')?
	//// ProbabilityMassFunction -> BOOLPMF ('(' 'ordered' ')')? '[' (boolsample)+ ']' ('[' Unit ']')?
	//ProbabilityMassFunction: // Numeric PMF
	//	'IntPMF' '[' samples+=numeric_int_sample+ ']' ('[' unit=Unit ']')? | 'DoublePMF' '[' samples+=numeric_real_sample+ ']'
	//	('[' unit=Unit ']')? | // Enum PMF
	//	'EnumPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=stringsample+ ']' | // Bool PMF
	//	'BoolPMF' ('(' orderedDomain?='ordered' ')')? '[' samples+=boolsample+ ']';
	public ProbabilityMassFunctionElements getProbabilityMassFunctionAccess() {
		return pProbabilityMassFunction;
	}
	
	public ParserRule getProbabilityMassFunctionRule() {
		return getProbabilityMassFunctionAccess().getRule();
	}
	
	//// numeric_int_sample -> '(' SIGNED_INT ';' DOUBLE ')'
	//numeric_int_sample IntSample:
	//	'(' value=SIGNED_INT //INT
	//	';' probability=DOUBLE //DOUBLE
	//	')';
	public Numeric_int_sampleElements getNumeric_int_sampleAccess() {
		return pNumeric_int_sample;
	}
	
	public ParserRule getNumeric_int_sampleRule() {
		return getNumeric_int_sampleAccess().getRule();
	}
	
	//// numeric_real_sample -> '(' SIGNED_NUMBER ';' DOUBLE ')'
	//numeric_real_sample DoubleSample:
	//	'(' value=SIGNED_NUMBER //DOUBLE
	//	';' probability=DOUBLE //DOUBLE
	//	')';
	public Numeric_real_sampleElements getNumeric_real_sampleAccess() {
		return pNumeric_real_sample;
	}
	
	public ParserRule getNumeric_real_sampleRule() {
		return getNumeric_real_sampleAccess().getRule();
	}
	
	//// real_pdf_sample -> '(' SIGNED_NUMBER ';' DOUBLE ')'		
	//real_pdf_sample ContinuousSample:
	//	'(' value=SIGNED_NUMBER //DOUBLE
	//	';' probability=DOUBLE //DOUBLE
	//	')';
	public Real_pdf_sampleElements getReal_pdf_sampleAccess() {
		return pReal_pdf_sample;
	}
	
	public ParserRule getReal_pdf_sampleRule() {
		return getReal_pdf_sampleAccess().getRule();
	}
	
	//// stringsample -> '(' STRING ';' DOUBLE ')'		
	//stringsample StringSample:
	//	'(' value=STRING ';' probability=DOUBLE //DOUBLE
	//	')';
	public StringsampleElements getStringsampleAccess() {
		return pStringsample;
	}
	
	public ParserRule getStringsampleRule() {
		return getStringsampleAccess().getRule();
	}
	
	//// boolsample -> '(' BOOLEAN_KEYWORDS ';' DOUBLE ')'
	//boolsample BoolSample:
	//	'(' value=BOOLEAN_KEYWORDS ';' probability=DOUBLE //DOUBLE 
	//	')';
	public BoolsampleElements getBoolsampleAccess() {
		return pBoolsample;
	}
	
	public ParserRule getBoolsampleRule() {
		return getBoolsampleAccess().getRule();
	}
	
	////#############################
	//// Datatype rules/terminals:
	//// SIGNED_NUMBER -> ('-')? DOUBLE
	//SIGNED_NUMBER ecore::EDouble:
	//	'-'? DOUBLE;
	public SIGNED_NUMBERElements getSIGNED_NUMBERAccess() {
		return pSIGNED_NUMBER;
	}
	
	public ParserRule getSIGNED_NUMBERRule() {
		return getSIGNED_NUMBERAccess().getRule();
	}
	
	//// SIGNED_INT -> ('-')? DECINT
	//SIGNED_INT ecore::EInt:
	//	'-'? DECINT;
	public SIGNED_INTElements getSIGNED_INTAccess() {
		return pSIGNED_INT;
	}
	
	public ParserRule getSIGNED_INTRule() {
		return getSIGNED_INTAccess().getRule();
	}
	
	//terminal DOUBLE returns ecore::EDouble:
	//	DECINT ('.' DIGIT* | ('.' DIGIT*)? ('E' | 'e') ('-' | '+')? DECINT);
	public TerminalRule getDOUBLERule() {
		return tDOUBLE;
	}
	
	//terminal DECINT returns ecore::EInt:
	//	'0' | '1'..'9' DIGIT*;
	public TerminalRule getDECINTRule() {
		return tDECINT;
	}
	
	//terminal BOOLEAN_KEYWORDS returns ecore::EBoolean:
	//	'false' | 'true';
	public TerminalRule getBOOLEAN_KEYWORDSRule() {
		return tBOOLEAN_KEYWORDS;
	}
	
	//terminal fragment DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal ID:
	//	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
	
	//terminal STRING:
	//	'\"' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '\"' |
	//	'\'' ('\\' ('b' | 't' | 'n' | 'f' | 'r' | 'u' | '"' | "'" | '\\') | !('\\' | '"'))* '\'';
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return tANY_OTHER;
	}
}
