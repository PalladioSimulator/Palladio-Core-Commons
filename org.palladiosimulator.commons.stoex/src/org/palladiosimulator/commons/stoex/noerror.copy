grammar org.palladiosimulator.StoEx with org.eclipse.xtext.common.Terminals

import "http://sdq.ipd.uka.de/StochasticExpressions/2.1" 
import "http://sdq.ipd.uka.de/ProbFunction/1.0"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

expression returns Expression:  
	ifelseExpr
; 

ifelseExpr returns IfElse:
	boolAndExpr ({IfElseExpression.conditionExpression=current} '?' ifExpression=boolAndExpr ':' elseExpression = boolAndExpr )?
;

boolAndExpr returns BooleanExpression:
	boolOrExpr ({BooleanOperatorExpression.left=current} operation=andoperation right=boolOrExpr)*
;
	
enum andoperation returns BooleanOperations:
	AND
;

boolOrExpr returns BooleanExpression:
	compareExpr ({BooleanOperatorExpression.left=current} operation=oroperations right=compareExpr)*
;

enum oroperations returns BooleanOperations:
	OR | XOR
;

compareExpr returns Comparison:
	sumExpr ({CompareExpression.left=current} operation=CompareOperations right=sumExpr)?
;
				 	
enum CompareOperations:
	GREATER | LESS | EQUALS | NOTEQUAL | GREATEREQUAL | LESSEQUAL 
;

sumExpr returns Term: 
	prodExpr ({TermExpression.left=current} operation=TermOperations right=prodExpr)?
;

//TODO:
enum TermOperations:
	ADD="+" | SUB="minus"
;
		
prodExpr returns Product:
	powExpr ({ProductExpression.left=current} operation=ProductOperations right=powExpr)*
;

enum ProductOperations:
	MULT="*" | DIV="/" | MOD="%"  
;

powExpr returns Power: 
	unaryExpr ({PowerExpression.base=current} POW exponent = unaryExpr)? 		
;

unaryExpr returns Unary :
	NegativeExpression | NotExpression | atom
;

NotExpression:
	NOT inner=unaryExpr
;
		  
NegativeExpression:
	"-" inner=unaryExpr
;
	
atom returns Atom:
	IntLiteral | 
	DoubleLiteral |
	StringLiteral | 
	BoolLiteral | 
	=> Variable | 
	FunctionLiteral | 
	Parenthesis | 
	ProbabilityFunctionLiteral
;

DoubleLiteral:
	value=NUMBER
;

ProbabilityFunctionLiteral:
	function_ProbabilityFunctionLiteral=definition
;

Parenthesis:
	LPAREN innerExpression = ifelseExpr RPAREN
;          

FunctionLiteral:
	id=ID LPAREN (parameters_FunctionLiteral+=boolAndExpr (COLON)? )* RPAREN
;

Variable:
	id_Variable=AbstractNamedReference
;

AbstractNamedReference:
	 VariableReference|NamespaceReference
;

VariableReference:
	referenceName=ID
;

NamespaceReference:
	referenceName=ID DOT innerReference_NamespaceReference=AbstractNamedReference
;

BoolLiteral:
	value=BOOLEAN_KEYWORDS
;

StringLiteral:
	value=STRING_LITERAL
;

IntLiteral:
	value=DECINT unit?
;


//TODO?! units?
unit:
	SQUARE_PAREN_L unit_spec SQUARE_PAREN_R
;


unit_spec_atom: 
	ID | ID POW NUMBER
;
	
unit_spec: 
	unit_spec_atom  | unit_spec_atom "/" unit_spec
;


definition returns ProbabilityFunction: 
	ProbabilityMassFunction 
	| ProbabilityDensityFunction
;

ProbabilityDensityFunction:
	BoxedPDF
;

BoxedPDF:
			DOUBLEPDF
				
			SQUARE_PAREN_L 
				( 
				  samples+=real_pdf_sample
				 )+ 
	 		SQUARE_PAREN_R unit?
;

ProbabilityMassFunction:
	// Numeric PMF
			
			INTPMF
			SQUARE_PAREN_L 
				(samples+=numeric_int_sample)+ 
	 		SQUARE_PAREN_R unit?
	 		|
		 	DOUBLEPMF 
				SQUARE_PAREN_L 
				(samples+=numeric_real_sample)+ 
			SQUARE_PAREN_R unit?
			| 
		// Enum PMF
			ENUMPMF 
				
			(LPAREN
			  ORDERED_DEF
			  
			RPAREN)?
			SQUARE_PAREN_L 
				( 
				samples+=stringsample
			   	)+ 
			SQUARE_PAREN_R
			
			|
			BOOLPMF 
				
			(LPAREN
			  ORDERED_DEF
			  
			RPAREN)?
			SQUARE_PAREN_L 
				( 
				samples+=boolsample
			   	)+ 
			SQUARE_PAREN_R
;	 		

numeric_int_sample returns IntSample: 
	LPAREN value=SIGNED_INT //INT
	SEMI probability=DOUBLE  //DOUBLE
	RPAREN
;
		
numeric_real_sample returns DoubleSample: 
	LPAREN value=SIGNED_NUMBER//DOUBLE
	SEMI probability=DOUBLE //DOUBLE
	RPAREN
;
			
real_pdf_sample returns ContinuousSample: 
	LPAREN value=SIGNED_NUMBER//DOUBLE
	SEMI probability=DOUBLE //DOUBLE
	RPAREN
;
			
stringsample returns StringSample: 
	LPAREN value=STRING_LITERAL 
	SEMI probability=DOUBLE //DOUBLE
	RPAREN
;

boolsample returns BoolSample: 
	LPAREN value=BOOLEAN_KEYWORDS
	SEMI probability=DOUBLE //DOUBLE 
	RPAREN
;

terminal BOOLEAN_KEYWORDS  returns ecore::EBoolean:
	FALSE | TRUE
;

terminal SIGNED_NUMBER  returns ecore::EDouble:
	("-")? NUMBER
;

terminal SIGNED_INT returns ecore::EIntegerObject:
	("-")? DECINT
;

/*terminal CHARECTERISATION_KEYWORDS returns ecore::EString:
 	BYTESIZE | STRUCTURE | NUMBER_OF_ELEMENTS | TYPE | VALUE
;*/
 	
/*//NO-TO-DO anymore: implement iscopeprovider
//scoped_id returns AbstractNamedReference:
terminal SCOPED_ID:
	REFNAMESTRING
;

terminal REFNAMESTRING  returns ecore::EString:
	ID(DOT (ID | INNER ))*
;

terminal REFNAMESTRING  returns ecore::EString:
	ID(DOT ID)*
;*/

//terminal OR_LIT: 'OR';
//terminal XOR_LIT: 'XOR';
//terminal AND_LIT: 'AND';
terminal NOT: 'NOT';

terminal INTPMF: 'IntPMF';
terminal DOUBLEPMF: 'DoublePMF';
terminal ENUMPMF: 'EnumPMF';
terminal DOUBLEPDF: 'DoublePDF';
terminal BOOLPMF: 'BoolPMF';

//terminal UNIT_TERMINAL: 'unit';

//terminal BOOL: '"bool"';
terminal FALSE: 'false';
terminal TRUE: 'true';

/*terminal BYTESIZE: 'BYTESIZE';
terminal STRUCTURE: 'STRUCTURE';
terminal NUMBER_OF_ELEMENTS: 'NUMBER_OF_ELEMENTS';
terminal TYPE: 'TYPE';
terminal VALUE: 'VALUE';*/
//terminal INNER: 'INNER';

//terminal PLUS  : '+' ;
//terminal MINUS : '-' ;
//terminal MULT   : '*' ;
//terminal DIV   : '/' ;
//terminal MOD   : '%' ;
terminal POW   : '^' ;

terminal LPAREN: '(' ;
terminal RPAREN: ')' ;

terminal SEMI: ';' ;
terminal COLON:	',';

//terminal DEFINITION_TERMINAL : '=' ;

terminal ORDERED_DEF: 'ordered';

//terminal EQUALS : '==' ;

terminal SQUARE_PAREN_L : '[' ;
terminal SQUARE_PAREN_R : ']' ;

terminal fragment  DIGIT : '0'..'9' ;
terminal NUMBER  returns ecore::EDouble: (DIGIT)+ ('.' (DIGIT)+)? EXPONENT?;
terminal fragment EXPONENT : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;

terminal fragment ALPHA : 'a'..'z' | 'A'..'Z' ;

/*terminal NOTEQUAL: '<>' ;
terminal GREATER: '>' ;
terminal LESS: '<' ;
terminal GREATEREQUAL: '>=' ;
terminal LESSEQUAL: '<=' ;*/

terminal STRING_LITERAL returns ecore::EString: '\"' (ALPHA|'_'|' '|DIGIT)+ '\"' ;
terminal DOT: '.';
terminal ID:(ALPHA|'_')+;

terminal DOUBLE returns ecore::EDouble: DECINT (('.' DIGIT*) | (('.' DIGIT*)? ('E'|'e') ('-'|'+')? DECINT));
terminal DECINT returns ecore::EInt: '0' | ('1'..'9' DIGIT*);